## event loop

The entire script is initially executed as a macro task

This means that the JS Engine is just an on-demand execution environment for any arbitrary JS code.
So, for example, when your JavaScript program makes an Ajax request to fetch some data from the server, you set up the ‚Äúresponse‚Äù code in a function (the ‚Äúcallback‚Äù), and the JS Engine tells the hosting environment:
‚ÄúHey, I‚Äôm going to suspend execution for now, but whenever you finish with that network request, and you have some data, please call this function back.‚Äù

It‚Äôs interesting to note that ES6 specifies how the event loop should work, meaning that technically it‚Äôs within the scope of the JS engine‚Äôs responsibilities, which is no longer playing just a hosting environment role. One main reason for this change is the introduction of Promises in ES6 because the latter require access to a direct, fine-grained control over scheduling operations on the event loop queue

## building the page at runtime

When the browser reaches the script node in the page-building phase, it pauses the DOM construction based on HTML code and starts executing JavaScript code instead.

# Js toolbox üõ†

arr.slice() to create copy of array

# Notes

as of this writing, in chrome, the number of recursive calls you can make is around 10 thousands and in Firefox it is 50 thousands
https://www.greatfrontend.com/questions/javascript/flatten

Math.hypot 


# Github: https://github.com/lydiahallie/javascript-questions

- All object keys are string (except Symbol)
- With "use strict", you can make sure that you don't accidentally declare global variables.
- eval evaluates codes that's passed as a string.
- If you have two keys with the same name, the key will be replaced. It will still be in its first position, but with the last specified value.
- The JavaScript global execution context creates two things for you: the global object, and the "this" keyword. (26)
- Primitive strings are automatically converted into a string object, generated by the string prototype function. So, all strings (string objects) have access to that method!
- when we stringify an object, it becomes "[object Object]"
- The deepest nested element that caused the event is the target of the event. You can stop bubbling by event.stopPropagation
- During event propagation, there are 3 phases: capturing, target, and bubbling. By default, event handlers are executed in the bubbling phase
- Function constructors, like new Number and new Boolean are truthy. // new Boolean(false) is truthy
- There are 8 falsy values
- A string is an iterable. The spread operator maps every character of an iterable to one element.
- When we don‚Äôt return a value from the function, the function returns undefined
- Temporal Dead Zone (es6)
- An imported module is read-only: you cannot modify the imported module. Only the module that exports them can change its value.
- The value of the accumulator is equal to the previously returned value of the callback function. If you don't pass the optional initialValue argument to the reduce method, the accumulator is equal to the first element on the first call (and curr value is equal to 2nd element I think).
- With the import keyword, all imported modules are pre-parsed. This means that the imported modules get run first, the code in the file which imports the module gets executed after.

Js PsDs
https://github.com/trekhleb/javascript-algorithms

// 67
## Revisit:

- 8 (static in class)
- 13, 31, 32 (event propagation)
- 17 (template literals)
- 22 (sessionStorage)
- 24, 56 (Set)
- 40 - [1].concat([]) is not [1,[]]???
- 44 (generator)
- 45 (Promise.race)
- 46, 50, 54, 58 Tricky and Nice!
- 49 (parseInt, radix)
- 65 (BEST explanation of reducer!)
- 66 class extend
- 68 (wrapper)

## Somewhat:

- 19 (‚Ä¶ in arguments)
- 23 (multiple var with same variable)
- 28 (IIFE and scoping and (x=1),(y=2))
- 52 (throw error)
- 57, 67 (import)
- 61 (defineProperty)